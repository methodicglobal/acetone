// Moved copy from original unit test project to isolate SF dependencies
using System;using System.Collections.Generic;using System.Fabric;using System.Fabric.Description;using System.Fabric.Query;using System.IO;using System.Linq;using System.Text.RegularExpressions;using System.Threading.Tasks;using System.Xml.Linq;using Methodic.Acetone;namespace Methodic.Acetone.IntegrationTests { public class ServiceFabricTestClusterManager : IDisposable { private readonly FabricClient fabricClient; private readonly ILogger logger; private readonly List<string> deployedApplications = new List<string>(); private readonly string clusterEndpoint; private bool isDisposed; private string imageStoreConnectionString; private readonly HashSet<(string TypeName,string TypeVersion)> provisionedApplicationTypes = new HashSet<(string,string)>(); private bool cleanupInvoked; public bool IsClusterAvailable { get; private set; } public IReadOnlyList<string> DeployedApplications => deployedApplications.AsReadOnly(); public ServiceFabricTestClusterManager(string clusterEndpoint, ILogger logger) { this.clusterEndpoint = clusterEndpoint ?? throw new ArgumentNullException(nameof(clusterEndpoint)); this.logger = logger ?? throw new ArgumentNullException(nameof(logger)); try { fabricClient = new FabricClient(clusterEndpoint); var clusterHealth = fabricClient.HealthManager.GetClusterHealthAsync().GetAwaiter().GetResult(); IsClusterAvailable = true; logger.WriteEntry($"Connected to Service Fabric cluster at {clusterEndpoint}", LogEntryType.Informational); } catch (Exception ex) { IsClusterAvailable = false; logger.WriteEntry($"Could not connect to Service Fabric cluster: {ex.Message}", LogEntryType.Warning); } } public async Task<List<string>> DeploySolutionApplicationsAsync(){ var results = new List<string>(); if(!IsClusterAvailable) return results; string root = TryLocateSolutionRoot(); if(root==null) return results; var apps = new List<(string app,string service)>{("MockApplication","MockApi"),("MockSystem","MockService")}; string imageStoreConnection = await GetImageStoreConnectionStringAsync(); foreach(var tuple in apps){ try{ string appPath = Path.Combine(root, tuple.app); string servicePath = Path.Combine(root, tuple.service); string applicationManifestPath = Path.Combine(appPath,"ApplicationPackageRoot","ApplicationManifest.xml"); if(!File.Exists(applicationManifestPath)) continue; if(!TryParseApplicationManifest(applicationManifestPath,out var manifest)) continue; bool alreadyProvisioned=false; try{ var currentTypes=await fabricClient.QueryManager.GetApplicationTypeListAsync(); alreadyProvisioned=currentTypes.Any(t=>t.ApplicationTypeName.Equals(manifest.ApplicationTypeName,StringComparison.OrdinalIgnoreCase)&& t.ApplicationTypeVersion.Equals(manifest.ApplicationTypeVersion,StringComparison.OrdinalIgnoreCase)); } catch{} string stagingRoot=null; string imageStorePath=$"IT_{manifest.ApplicationTypeName}_{Guid.NewGuid():N}"; bool uploaded=false; try{ if(!alreadyProvisioned){ stagingRoot=PrepareSolutionApplicationPackage(appPath, servicePath, manifest); if(stagingRoot==null) continue; fabricClient.ApplicationManager.CopyApplicationPackage(imageStoreConnection, stagingRoot, imageStorePath); uploaded=true; await fabricClient.ApplicationManager.ProvisionApplicationAsync(imageStorePath); provisionedApplicationTypes.Add((manifest.ApplicationTypeName,manifest.ApplicationTypeVersion)); } string instanceName=$"IT{manifest.ApplicationTypeName}Tests"; var appUri=new Uri($"fabric:/{instanceName}"); var existing=await fabricClient.QueryManager.GetApplicationListAsync(appUri); if(!existing.Any()){ await fabricClient.ApplicationManager.CreateApplicationAsync(new ApplicationDescription(appUri,manifest.ApplicationTypeName,manifest.ApplicationTypeVersion)); await Task.Delay(300); } if(!deployedApplications.Contains(instanceName)) deployedApplications.Add(instanceName); results.Add(instanceName); } finally { if(uploaded) { try { fabricClient.ApplicationManager.RemoveApplicationPackage(imageStoreConnection,imageStorePath);} catch{} } if(stagingRoot!=null && Directory.Exists(stagingRoot)) { try { Directory.Delete(stagingRoot,true);} catch{} } } } catch{} } return results; } private string PrepareSolutionApplicationPackage(string appProjectPath,string serviceProjectPath, ApplicationManifestInfo manifest){ string staging=Path.Combine(Path.GetTempPath(),$"ITPkg_{manifest.ApplicationTypeName}_{Guid.NewGuid():N}"); try{ Directory.CreateDirectory(staging); File.Copy(Path.Combine(appProjectPath,"ApplicationPackageRoot","ApplicationManifest.xml"),Path.Combine(staging,"ApplicationManifest.xml")); foreach(var svc in manifest.ServiceManifests){ string sourceRoot=Path.Combine(serviceProjectPath,"PackageRoot"); if(!Directory.Exists(sourceRoot)) return null; string target=Path.Combine(staging, svc.ServiceManifestName); CopyDirectory(sourceRoot,target); string codeDir=Path.Combine(target,"Code"); if(Directory.Exists(codeDir)) Directory.Delete(codeDir,true); Directory.CreateDirectory(codeDir); string buildOutput=TryLocateLatestBuildOutput(serviceProjectPath); if(buildOutput==null) return null; foreach(var f in Directory.GetFiles(buildOutput)){ var name=Path.GetFileName(f); if(name.EndsWith(".pdb",StringComparison.OrdinalIgnoreCase)) continue; File.Copy(f,Path.Combine(codeDir,name),true); } } return staging; } catch{ try{ if(Directory.Exists(staging)) Directory.Delete(staging,true);} catch{} return null; } } private static string TryLocateLatestBuildOutput(string serviceProjectPath){ try{ string bin=Path.Combine(serviceProjectPath,"bin"); if(!Directory.Exists(bin)) return null; return Directory.GetDirectories(bin,"*",SearchOption.AllDirectories).Select(d=>new DirectoryInfo(d)).OrderByDescending(d=>d.LastWriteTimeUtc).FirstOrDefault()?.FullName; } catch{ return null; } } private static bool TryParseApplicationManifest(string path,out ApplicationManifestInfo info){ info=null; try{ var doc=XDocument.Load(path); XNamespace ns="http://schemas.microsoft.com/2011/01/fabric"; var root=doc.Root; if(root==null) return false; string typeName=(string)root.Attribute("ApplicationTypeName"); string typeVersion=(string)root.Attribute("ApplicationTypeVersion"); if(string.IsNullOrWhiteSpace(typeName)||string.IsNullOrWhiteSpace(typeVersion)) return false; var imports=root.Elements(ns+"ServiceManifestImport").Select(e=>e.Element(ns+"ServiceManifestRef")).Where(e=>e!=null).Select(e=>new ServiceManifestRefInfo{ ServiceManifestName=(string)e.Attribute("ServiceManifestName"), ServiceManifestVersion=(string)e.Attribute("ServiceManifestVersion")}).Where(s=>!string.IsNullOrWhiteSpace(s.ServiceManifestName)).ToList(); info=new ApplicationManifestInfo{ApplicationTypeName=typeName,ApplicationTypeVersion=typeVersion,ServiceManifests=imports}; return true; } catch{ return false; } } private class ApplicationManifestInfo { public string ApplicationTypeName{get;set;} public string ApplicationTypeVersion{get;set;} public List<ServiceManifestRefInfo> ServiceManifests{get;set;}=new List<ServiceManifestRefInfo>(); } private class ServiceManifestRefInfo { public string ServiceManifestName{get;set;} public string ServiceManifestVersion{get;set;} } public async Task RemoveAllDeployedApplicationsAsync(bool unprovision=false){ cleanupInvoked=true; if(!IsClusterAvailable) return; foreach(var app in deployedApplications.ToList()){ try{ await RemoveApplicationAsync(app); deployedApplications.Remove(app);} catch{} } if(unprovision){ foreach(var t in provisionedApplicationTypes.ToList()){ try{ await fabricClient.ApplicationManager.UnprovisionApplicationAsync(new UnprovisionApplicationTypeDescription(t.TypeName,t.TypeVersion)); provisionedApplicationTypes.Remove(t);} catch{} } } } private async Task RemoveApplicationAsync(string app){ try{ var uri=new Uri($"fabric:/{app}"); await fabricClient.ApplicationManager.DeleteApplicationAsync(new DeleteApplicationDescription(uri){ForceDelete=true}); } catch{} } private async Task<string> GetImageStoreConnectionStringAsync(){ if(!string.IsNullOrEmpty(imageStoreConnectionString)) return imageStoreConnectionString; try{ string manifest=await fabricClient.ClusterManager.GetClusterManifestAsync(); var m=Regex.Match(manifest,"Parameter\\s+Name=\"ImageStoreConnectionString\"\\s+Value=\"([^\"]+)\"",RegexOptions.IgnoreCase); if(m.Success){ imageStoreConnectionString=m.Groups[1].Value.Trim(); } } catch{} if(string.IsNullOrEmpty(imageStoreConnectionString)) imageStoreConnectionString="fabric:ImageStore"; return imageStoreConnectionString; } private static void CopyDirectory(string source,string dest){ Directory.CreateDirectory(dest); foreach(var f in Directory.GetFiles(source)){ File.Copy(f,Path.Combine(dest,Path.GetFileName(f)),true);} foreach(var d in Directory.GetDirectories(source)){ CopyDirectory(d,Path.Combine(dest,Path.GetFileName(d))); } } private static string TryLocateSolutionRoot(){ DirectoryInfo dir=new DirectoryInfo(AppDomain.CurrentDomain.BaseDirectory); for(int i=0;i<6 && dir!=null;i++){ if(Directory.GetFiles(dir.FullName,"*.sln").Any()) return dir.FullName; dir=dir.Parent; } return null; } public void Dispose(){ if(isDisposed) return; try{ if(!cleanupInvoked){ try{ RemoveAllDeployedApplicationsAsync(false).GetAwaiter().GetResult(); } catch{} } } finally { fabricClient?.Dispose(); isDisposed=true; } } } }